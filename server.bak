package websocket 

import (
	"fmt"
	"log/slog"
	"net"
	"os"
	"os/signal"
	"syscall"
)


func TerminateServer(host string, port string, listener net.Listener) {
	slog.Info(fmt.Sprintf("terminating listener: %s:%s", host, port))
	listener.Close()
}

func StartServer(host string, port string) {
	address := net.JoinHostPort(host, port)

	// start listener
	listener, err := net.Listen("tcp", address)
	if err != nil {
		slog.Error(fmt.Sprintf("failed to start server: %s", err))
	}
	defer TerminateServer(host, port, listener)

	slog.Info(fmt.Sprintf("starting server: %s:%s", host, port))

	conns := make(map[net.Conn]struct{})
	connsCh := make(chan net.Conn)
	closeCh := make(chan net.Conn)
	termCh := make(chan struct{})

	// termination handler
	go func() {
		sigCh := make(chan os.Signal, 1)
		signal.Notify(sigCh, os.Interrupt, syscall.SIGTERM)
		<-sigCh
		slog.Info("shutting down")

		for c := range conns {
			_ = c.Close()
		}
		listener.Close()
		close(termCh)
	}()

	// manages connection map (keeps updated)
	go func() {
		for {
			select {
			case c := <- connsCh:
				conns[c] = struct{}{}
				slog.Info(fmt.Sprintf("new connection: %s", c.LocalAddr()))
			case c := <- closeCh:
				delete(conns, c)
				slog.Info(fmt.Sprintf("closed connection: %s", c.LocalAddr()))
			case <-termCh:
				return
			}
		}
	}()


	// handle connection acceptance
	for {
		c, err := listener.Accept()

		if err != nil {
			select {
			case <- termCh:
				return
			default:
				slog.Error(fmt.Sprintf("was unable to accept connection: %s", err))
				continue
			}
		}

		// track new connection 
		connsCh <- c

		// handle new connection
		go func(conn net.Conn){
			defer conn.Close()
			defer func(){ closeCh <- conn }()

			buf := make([]byte, 4096)
			for {
				n, err := c.Read(buf)
				if err != nil {
					return
				}

				// echo back received data
				_, err = c.Write(buf[:n])
				if err != nil {
					return
				}
			}
		}(c)
	}

}
